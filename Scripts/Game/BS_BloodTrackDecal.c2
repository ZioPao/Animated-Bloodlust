// Spawns Track Decal





//make a stack and replace them. 



[ComponentEditorProps(category: "GameScripted/Test", description:"BS_BloodTrackDecal", color: "0 0 255 255")]
class BS_BloodTrackDecalClass : ScriptComponentClass
{
};

class BS_BloodTrackDecal : ScriptComponent
{	
	[Attribute("", UIWidgets.ResourceNamePicker, desc: "Material for track decal", params: "emat")]
	private ResourceName m_TrackMaterial;
	
	

	ref TrackBloodDecalInfo trackBloodDecalInfo;

	
	int invocationCounter;
	
	
	void SetupBloodTrail()
	{
		if (!trackBloodDecalInfo)
			trackBloodDecalInfo = new TrackBloodDecalInfo();
		
		invocationCounter = 0;
	
	}
	
	
	
	void UpdateBloodtrail()
	{
		IEntity owner = GetOwner();
		vector position;
		vector normal;
		vector intersectionPosition;
		TraceParam traceParam;

		if (invocationCounter > 100)
				GetGame().GetCallqueue().Remove(UpdateBloodtrail);

		float lifetime = 120.0;
		
		
		traceParam = BS_AnimatedBloodManager.GetSurfaceIntersection(owner, GetGame().GetWorld(), owner.GetOrigin(), Vector(0, -1, 0), 2, TraceFlags.WORLD | TraceFlags.ENTS, intersectionPosition);
		position = owner.GetOrigin();
		normal = "0 -1 0";		//for now 
		
		if (!trackBloodDecalInfo.m_Decal)
		{
			if (trackBloodDecalInfo.m_bConnectToPrevious)
			{
				Print("Should continue from older values?");
				trackBloodDecalInfo.m_Decal = GetOwner().GetWorld().CreateTrackDecal(traceParam.TraceEnt, trackBloodDecalInfo.m_vLastTracePos, trackBloodDecalInfo.m_vLastTraceNormal, 0.25, lifetime, m_TrackMaterial, null, 1.0);
				trackBloodDecalInfo.m_bConnectToPrevious = false;
			}
			else 
			{
				Print("Create new tracked Decal");
				trackBloodDecalInfo.m_Decal = GetOwner().GetWorld().CreateTrackDecal(traceParam.TraceEnt, position, normal, 0.25, lifetime, m_TrackMaterial, null, 0.0);
			}
		
		}
		else if (vector.DistanceSq(trackBloodDecalInfo.m_vLastAxlePos, position) > 0.2)
		{
			trackBloodDecalInfo.m_vLastAxlePos = position;
			int validationEnum = trackBloodDecalInfo.m_Decal.CanAddToTrackDecal(traceParam.TraceEnt, m_TrackMaterial, position);
			
			switch (validationEnum)
			{
				case -1:
				{
					Print("Error for UpdateBloodTrack");
					break;
				}
				case 0:
				{
					Print("Valid");
					trackBloodDecalInfo.m_fLength += vector.Distance(position, trackBloodDecalInfo.m_vLastTracePos);
						
					
					
					
					
					if(!trackBloodDecalInfo.m_Decal.AddPointToTrackDecal(position, normal, 1.0))
					{
						trackBloodDecalInfo.Finalize(0.0);
						Print("Finalized point");
					}
					
					/*
					if (invocationCounter > 3)
					{
						trackBloodDecalInfo.m_Decal.FinalizeTrackDecal(false, 0);
						trackBloodDecalInfo.m_Decal = null;
						
						trackBloodDecalInfo = new TrackBloodDecalInfo();		//reset?
						invocationCounter = 0;		//reset
					
					
					}
					*/
					break;
				}
				case 1:
				{
					Print("Different entity");
					TrackDecal oldDecal = trackBloodDecalInfo.m_Decal;
					oldDecal.FinalizeTrackDecal(false, 0);
						
					trackBloodDecalInfo.m_Decal = GetOwner().GetWorld().CreateTrackDecal(traceParam.TraceEnt, position, normal, 0.25, 120.0, m_TrackMaterial, oldDecal, 1.0);
					trackBloodDecalInfo.m_bConnectToPrevious = false;
					break;
				}
				case 2:
				{
					Print("Too far");
					trackBloodDecalInfo.Finalize(0.1);
					trackBloodDecalInfo.m_fLength = 0.0;
					trackBloodDecalInfo.m_Decal = GetOwner().GetWorld().CreateTrackDecal(traceParam.TraceEnt, position, normal, 0.25, 120.0, m_TrackMaterial, null, 0.0);
					trackBloodDecalInfo.m_bConnectToPrevious = false;
					break;
				}
			
			}
		
		}
		
		trackBloodDecalInfo.m_vLastTracePos = position;
		trackBloodDecalInfo.m_vLastTraceNormal = normal;
		invocationCounter++;
	}		
};



class TrackBloodDecalInfo
{
	TrackDecal m_Decal;
	vector m_vLastAxlePos;
	vector m_vLastTracePos;
	vector m_vLastTraceNormal;
	float m_fLength;
	bool m_bConnectToPrevious;
	
	void TrackBloodDecalInfo()
	{
		m_Decal = null;
		m_vLastAxlePos = vector.Zero;
		m_vLastTracePos = vector.Zero;
		m_vLastTraceNormal = vector.Zero;
		m_fLength = 0;
		m_bConnectToPrevious = false;
	}
	
	void Finalize(float dist)
	{
		if(!m_Decal) return;
		
		if(dist < 0.01)
		{
			m_Decal.FinalizeTrackDecal(false, 0);
			m_bConnectToPrevious = true;
		}
		else
		{
			m_Decal.FinalizeTrackDecal(true, dist);
			m_bConnectToPrevious = false;
		}
		
		m_Decal = null;
		m_fLength = 0;
	}
};